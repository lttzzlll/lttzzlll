---
layout: default
title: 学习正则表达式
---

{{ page.title }}

正则表达式功能：查找某个字符串，返回“匹配上”或者“匹配不上”。  
* 一般将正则表达式的模式放在正斜线(//)之间，如下：
```
Perl
$_ = "yabba dabba doo";
if (/abba/) { // 默认匹配$_的内容
    print "It matched!\n";
}
输出：It matched! #注意换行
```
表达式/abba/将在$_寻找这四个字母。如果找到，返回true，否则，false。   
如果找到了，则匹配上；否则，没有匹配上。   
注意：由于模式匹配成功通常返回true或false，因此经常用在if或while的条件表达式中。   
所有在双引号中的转义字符在模式中均有效。包括\t,\n等等。   
* 元字符   
在正则表达式中具有特殊含义的字符。   

| 元字符 | 名称| 功能 | 常用 |
| :-----: | :-----: | :-----: | :-----: |
| . | 通配符 | 匹配任何单个的字符（但不包括换行符\n） | .* 任意字符串匹配模式 -> 任意的字符串均能被匹配上（不包括换行符） |
| \ | 反斜线 | 将元字符变成普通的字符 \\ |  |
| * | 数量词 | 匹配前一项0次或者多次 |  |
| + | 数量词 | 匹配前一项1次或者多次 | |
| ? | 数量词 | 匹配前一项0次或者1次 | | 
| () | 分组 | | |
| | | 或者 | 匹配左边的或者右边的 | cat|dog |
| [] | 字符类 | 匹配括号内出现的任意单个字符 | [a-zA-Z0-9] |
| - | 连字号 | 表示某个范围 | [0-9A-Za-z] |
| ^ | 补集 | 表示某个集合的补集 | [^\d] 匹配数字之外的任意字符 |
| \d | 数字 | 数字的简写 | \d = [0-9] [^\d] 非数字的字符 |
| \w | 字符 | 表示字符 | \w = [a-zA-Z0-9_] 包括下划线（字母，数字，下划线）\w+匹配整个单词 [^\w] 非单词的字符 |
| \s | 空白 | 表示空白字符 | \s = [\f\t\n\r] \s*将匹配任何个数的空白字符（包括没有） \s+ 匹配一个以上的空白字符 [^\s] 非空白的字符 | 
| \D | [^\d]的补集 | 非数字的字符 | |
| \W | [^\w]的补集 | 非单词的字符 | | 
| \S | [^\s]的补集 | 非空白的字符 | |
| [\d\D] | 任何的数字，和任何非数字，指任何字符 | 匹配所有字符的一种通用方法 | /[\dA-Fa-f]+ 匹配16进制/ |
| [^\d\D] | 没有意义 | | |
| {} | 数量词 | 表示数量的范围 | {0, 3}, {0, }, {, 3} 包含上下界 * == {0, }, + == {1, }, ? == {0, 1} |

元字符前使用反斜线将使它变成普通的字符。   

小练习   
1. 写一个程序，输出所有提到 fred的行（不要输出其它行）。如果输入字符串 Fred, fredrick, Alfred，能匹配上吗？准 备一个小的文本文件，其中包含如：“fred lintsotne”以及类似的信息。使用这个文本文件作为此程序的输入，以及本节 下面练习的输入。    
```
Perl
my @lines = qw/Fred, fredrick, Alfred/;
foreach $_(@lines) {
    if ($_ =~ /fred/) {
        print "mathed\n";
    } else {
        print "Do not matched!\n";
    }
}
output:   
Do not matched!   
mathed   
mathed    
```
2. 修改上面的程序，允许匹配 Fred。现在它能匹配，Fred, fredrick, Alfred 吗?（将这些名字加入输入文件中）    
```
Perl
my @lines = qw/Fred, fredrick, Alfred/;
foreach $_(@lines) {
    if ($_ =~ /fred/i) {
        print "mathed\n";
    } else {
        print "Do not matched!\n";
    }
}
output: 
mathed
mathed
mathed
```
3. 写一个程序，输出出现句号(.)的行，忽略其它行。使用前面练习中的文件进行练习：它能找到 Mr. Slate 吗？   
```
my @lines = qw/Fred, fredrick, Alfred, Mr.Slate/;
foreach $_(@lines) {
    if ($_ =~ /\./i) {
        print "$_\n";
    }
}
output:
Mr.Slate
```
4. 写一个程序，输出有一个字母大写，而非所有字母都大写的行。它能匹配Fred，而不匹配 fred和 FRED吗？   
```
my @lines = qw/Fred, fredrick, Alfred, Mr.Slate/;
foreach $_(@lines) {
    if ($_ =~ /[A-Z]+[a-z]+|[a-z]+[A-Z]+/) {
        print "$_\n";
    }
}
output:
Fred,
Alfred,
Mr.Slate
```
5. 额外的练习：写一个程序，它能输出所有同时提到 wilma和 fred 的行   
```
my $line1 = "wlima and fred";
my $line2 = "hello wlima";
my $line3 = "hello fred";
my $line4 = "fuck you!";
my @line = ();
push @line, $line1;
push @line, $line2;
push @line, $line3;
push @line, $line4;

foreach $_(@line) {
    if ($_ =~ /wlima/ && $_ =~ /fred/) {
        print "$_\n";
    }
}
```

> m// == //  
> m(fred) == m<fred> == m{fred} == m[fred] == m,fred, == m!fred! == m^fred^
> /http:\/\// == m%http://% == m{http://}  
> 正斜线不是元字符，如果它不是分隔符，则不需要在前面使用反斜线。  
可选的修饰符   
| 修饰符 | 功能 | 常用 | 
| :-----: | :-----: | :-----: |
| /i | 不区分大小写 | /pattern/i |
| /s | 匹配任何字符 | /.*/s . 不匹配换行符，但是当 /.*/s 添加时，可以匹配换行符 |
| /x | 允许在模式中添加空格 | /-? \d+ \.? \d* /x (匹配数字) |

锚定：模式可以在特定的位置进行匹配   
| 符号 | 功能 | 常用 |
| :-----: | :-----: | :-----: |
| ^ | 在字符串的开头进行匹配 | /^hello/ | 
| & | 在字符串的结尾进行匹配 | /hello$/ (可能会匹配结尾的换行符) |
/^\s*$/ 匹配一个空行  
> 词界锚定：\b，针对单次使用 /\bhello\b/ 匹配 "hello"，不能匹配 "helloworld"，相当于全词匹配。   
> 给定字符串总有偶数个词界，每一个词均有两个界限（开始和结尾）。    
> 词是字母，数字，下划线组成的序列。 /\w+/ == /[A-Za-Z0-9_]+/   
> 单词上的引号不会改变词界的位置。   每一个单词上的引号都会使得单词的词界从此处重新开始。   
> 非词界锚定：\B，他将在任何非\b匹配的点上进行匹配。 /\bsearch\B/ 将匹配searches, searching, searched，但是不能匹配search，或者researching。   
> 绑定操作符 =~，将右边的模式在左边的字符串上进行匹配，默认对$_上的内容进行匹配。  
正则表达式可以被内插，作为内嵌的变量插入待匹配的模式中。   
匹配变量，允许取出相应的字符串。  
```
$_ = "Hello there, neighbor";
if (/\s(\w+),/) {
    print("the word was $1\n");
}
output:
the word was there
$_ = "Hello there, neighbor";
if (/(S+) (S+) (S+)/) {
    print("words were $1 $2 $3");
}
output:
words were Hello there neighbor
```
> 匹配变量可能是空的，如果没有被匹配上，匹配变量的值可能为空串。   
> 不同于undefined，如果模式中只有3个或者更少的括号，那么 $4为undef
```
my $dino = "I fear that I'll be extinct after 1000 years";
if ($dino =~ /(\d*) years/) {
    print("That's said '$1' years.\n");
}
output:
That's said '1000' years.

my dino = "I fear that I'll be extinct after a few millions years.";
if ($dino =~ /(\d*) years/) {
    print("That's said '$1' years.\n");
}
output:
That's said '' years.
```
匹配变量的值会保持不变，直到下一个模式成功匹配。一个没有匹配成功的模式将不会改变内存中相应的值，但一个匹配上的模式将重写此内存。  所以每次匹配的时候都要用if判断一下有没有匹配成功。

优先级
1. ()
2. 数量词
3. 锚定和序列
4. | 

小练习   
1. 使用模式测试程序。创造一个模式能匹配字符串match。使用字符串beforematchafter 进行测试。输出结果将其三部分放在正确位置了吗？
```
my $line = "beforematchafter";
my $match = "(before)(match)(after)";
if ($line =~ /$match/) {
    print("$1, $2, $3");
}
output:
before, match, after
```
2. 使用模式测试程序，创造一个模式能匹配任何单词（\w 意义下的单词），但这个单词必需以字母a 结尾。它匹配 wilma 而没匹配 barney 吗？它匹配 Mrs. Wilma Flintstone 吗? wilma&fred 呢？使用前一章习题的文件进行练习（如果没有上 述字符串，则加上它们）
```
my @line = ();
push @line, "wilma";
push @line, "barney";
push @line, "Mrs. Wilma Flintstone";
push @line, "wilma&fred";
foreach $_(@line) {
    if ($_ =~ /a\b/) {
        print("$_\n");
    }
}
output:
wilma
Mrs. Wilma Flintstone
wilma&fred
```
3. 修改第二题的程序，使之将由a结尾的单词放到$1之中。同时修改源代码，使此变量对应的值被放在单引号之中， 如$1 containsW‘ ilma’ 。
```
my @line = ();
push @line, "wilma";
push @line, "barney";
push @line, "Mrs. Wilma Flintstone";
push @line, "wilma&fred";
foreach $_(@line) {
    if ($_ =~ /(a\b)/) {
        print("'$1'\n");
    }
}
output:
'a'
'a'
'a'
```
4. 额外练习：修改第三题程序，使之能捕捉由 a 结尾的单词之后的 5 个字符（如果有那么多），并将之放入一个独立变量中。例如，如果输入的是 I saw Wilma yesterday, 则紧接的 5个字符是 yest（前有空格）。如果输入是 I, Wilma!， 则只有一个字符。它现在还能匹配 wilma吗？
```
my @line = ();
push @line, "wilma";
push @line, "barney";
push @line, "Mrs. Wilma Flintstone";
push @line, "wilma&fred";
foreach $_(@line) {
    if ($_ =~ /(a\b)(.{0,5})/) {
        print("'$2'\n");
    }
}
output:
''
' Flin'
'&fred'
```
5. 写一个程序（不是测试程序），能输出任何由空白结尾的输入行（非换行符）。在输出的结尾处放置一个标记符，使之能标记出空白。
```
my @line = ();
push @line, "wilma ";
push @line, "barney  ";
push @line, "Mrs. Wilma Flintstone  ";
push @line, "wilma&fred         ";
foreach $_(@line) {
    if ($_ =~ s/(\s+)$/-/) {
        print("'$_'\n");
    }
}
output:
'wilma-'
'barney-'
'Mrs. Wilma Flintstone-'
'wilma&fred-'
```

m// 查询 s//查询并替换
```
$_ = "He's out bowling with Barney tonight.";
s/Barney/Fred/;
print("$_\n");

output:
He's out bowling with Fred tonight.
```
> 如果没有匹配上，则什么也不会发生，此变量也不会有任何更改。   
替换的字符串使用了变量$1,其值由模式匹配所赋值。    
```
$_ = "He's out bowling with Barney tonight.";
s/with (\w+)/agaist $1's team/;
print("$_\n");

output:
He's out bowling agaist Barney's team tonight.
```

更多的例子
```
$_ = "green scaly dinosaur";
s/(\w+) (\w+)/$2, $1/; # scaly, green dinosaur
s/^/huge,/; # huge, scaly, green dinosaur
s/,.*een//; # huge, dinosaur
```

s/// 会返回一个Boolean值。如果成功替换则返回true；否则返回false
```
$_ = 'fred flintstone';
if (s/fred/wilma/) {
    print ("Successfully replaced fred with wilma");
}

output:
Successfully replaced fred with wilma
```

s///只进行一次替换，无论是否还有地方还能匹配上。
> 修饰符/g要求s////将不想重叠的所有匹配上的部分都进行替换。   
> 每一次新的匹配都是从最近匹配成功的地方之后开始进行。  
```
$_ = "home, sweet home!";
s/home/cave/g;
print("$_\n");

output:
cave, sweet cave!
```

全局替换的一个常用地方是将多个空格用单个空格替换掉。   
```
$_ = "Input data\t may have     extra whitespace.";
s/\s+/ /g;
print("$_\n");

output:
Input data may have extra whitespace.
```

去掉开头的空白
```
s/^\s+//;
```
去掉结尾的空白
```
s/\s+$//;
```
去掉开头结尾的空白
```
s/^\s+|\s+$//g;
```

可以使用不同的配对符号
```
s{fred}{barney}; == s/fred/barney/;
s{fred}(barney); == s/fred/barney/;
s<fred>#barney#; == s/fred/barney/;
```

其他的可选的修饰符
> /i, 忽略大小写 /x, 允许匹配的模式中含有空白 /s 允许跨行匹配 (.*可以跨行匹配)

大小写
\U要求紧接着的均是大写
```
$_ = "I saw Barney with Fred";
s/(fred|barney)/\U$1/gi;
print("$_\n");

output:
I saw BARNEY with Fred
```
\L要求后面的均为小写
```
$_ = "I saw Barney with Fred";
s/(fred|barney)/\L$1/gi;
print("$_\n");

output:
I saw barney with Fred

$_ = "I saw Barney with Fred";
s/(\w+) with (\w+)/\U$2\E with $1/i;
print("$_\n");

output:
I saw FRED with Barney
```
添加\E之后，消除了对后面字符串的影响。   

```
$_ = "I saw Barney with Fred";
s/(fred|barney)/\u$1/ig;
print("$_\n");

output:
I saw Barney with Fred
```

使用\u\L表示“第一个字母大写，其他字母均小写”；两个字符出现的相对顺序不重要。
```
$_ = "I saw BaRney with Fred";
s/(fred|barney)/\u\L$1/ig;
print("$_\n");

output:
I saw Barney with Fred
```

记住规则：先匹配上，然后在替换（按照规则替换）；

split:根据某个模式将字符串分隔开。
```
@fields = split/:/, 'abc:def:g:h';
foreach $_(@fields) {
    print("$_\n");
}

output:
abc
def
g
h

@fields = split /:/, ":::a:b:c:::";
foreach $_(@fields) {
    print("$_\n");
}

output:



a
b
c

my $some_input ="This is a \t test.\n" ; 
my @args = split /\s+/, $some_input; # ("This" , "is" , "a" , "test.")

foreach $_(@args) {
    print("$_\n");
}

output:
This
is
a
test.
```

join 函数不使用模式，但它完成同split相反的操作；split将一个字符串分隔开，而join函数讲这些分隔开的部分组合成一个整体。
```
my $result = join $glue, @pieces;
my $x = join ":", 4, 6, 8, 10, 12;
print("$x\n");
my @values = split /:/, $x;
my $z = join "-", @values;
print("$z\n");
output:
4:6:8:10:12
4-6-8-10-12
```
> join的第一个参数是字符串，而非模式

在列表context中使用模式匹配(m//)时，如果匹配成功返回值为内存变量值得列表；如果匹配失败则为空列表。
```
$_ = "Hello there, neighbor";
my ($first, $second, $third) = /(\S+) (\S+), (\S+)/;
print("$second is my $third\n");

output:
there is my neighbor

my $text = "Fred dropped a 5 ton granite block on Mr.Slate";
my @words = ($text =~ /([a-z]+)/ig);
print("Result: @words\n");

output:
Result: Fred dropped a ton granite block on Mr Slate

my $data = "Barney Rubble Fred Filntstone Wilma Flintstone";
my %last_name = ($data =~ /(\w+)\S+(\w+)/g);

foreach(keys %last_name) {
    print "$_ => $last_name{$_}\n";
}

output:
Filntsto => e
Wil => a
Rubb => e
Flintsto => e
Barn => y
Fr => d
```

非贪恋的数量词
> + 是贪恋的，它将尽可能的进行匹配。   
> 对于每一个贪婪的数量词，需要一种非贪恋的方法。不是使用加号(+)，而是使用非贪恋的数量词+?，它将匹配一次或者多次，但其匹配尽可能少的次数，而非尽可能多的次数。
> + 的非贪恋类型是 +?   
> * 的非贪恋类型是 *?    
> {} 的非贪恋类型是 {}?   
> ? 的非贪恋类型是 ?? 它匹配0次或者1次，但倾向于匹配0次。

锚定^和$是指整个字符串的开头和结束。但/m这个正则表达式选择允许他们根据内部的换行符进行匹配（将m看做多行）。这时，锚定针对每一行，而非整个字符串。
```
$_ = "I'am much better\nthan Barney is\nat blowing,\nWilma,\n";
if ($_ =~ /wilma/im) {
    print("Found 'wilma' at start of line\n");
}

output:
Found 'wilma' at start of line
```
> 此处的修饰符/m可以理解为 multiple line   

小练习
1. 写一个模式，它能匹配$what当前的内容的3 份连续拷贝。也就是说，如果$what为 fred，则此模式能匹配 fredfredfred。 如果$what为 fred|barney，则此模式能匹配 fredfredbarney, barneyfredfred, barneybarneybarney,或者其它的变种。（提示： 你应当在程序的顶端设置$what 的值，如 my $what = ‘fred|barney’ ;）
```
my $what = "fred";
my $words = "Hello fredfredfred, how are you";
if ($words =~ /$what$what$what/) {
    print("matched!");    
}

output:
matched!
```

2. 写一个程序，它可以得到当前文本文件的一个拷贝。在拷贝的文件中，字符串 Fred(大小写无关)将被 Larry 替换掉。 （因此，“Manfred Mann”将变成 “ManLarry Mann” .）输入的文件名已经在命令行中指定（不需要询问用户），输出的 文件名是对应的输入文件名后面加上.out。
```
my $_ = "Manfred Mann";
if (s/fred/Larry/) {
    print("$_\n");
}

output:
ManLarry Mann
```

3. 修改上面程序，使之将 Fred由 Wilma替换，Wilma 由 Fred 替换。如果输入的为fred&wilma，则输出为 Wilma$Fred。
```
$_ = "hello,Wilma&Fred,world";
my ($wilma, $other, $fred) = m/(Wilma|Fred)(.*?)(Wilma|Fred)/;
s/(Wilma).*?(Fred)/$fred$other$wilma/;
print("$wilma,$fred\n");
print("$_\n");
```

4. 额外练习：写一个程序在你所有的练习的答案前加上下面这样一行：
a) ## Copyright (C) 20XX byYours Truly
```
my @line = ();
push @line, "Hello";
push @line, "word";
push @line, "this";
push @line, "is";
push @line, "a";
push @line, "test";
foreach $_(@line) {
    s/^/Copyright (C) 20XX byYours Truly/;
    print("$_\n");
}

output:
Copyright (C) 20XX byYours TrulyHello
Copyright (C) 20XX byYours Trulyword
Copyright (C) 20XX byYours Trulythis
Copyright (C) 20XX byYours Trulyis
Copyright (C) 20XX byYours Trulya
Copyright (C) 20XX byYours Trulytest
```

5. 额外练习：修改第四题程序，如果程序已经有 copyright 这一行，则不进行修改。提示：由<>读入的文件名可以在 $ARGV中找到。
```
my @line = ();
push @line, "Hello";
push @line, "Copyright (C) word";
push @line, "this";
push @line, "Copyright (C) is";
push @line, "a";
push @line, "test";
foreach $_(@line) {
    if (m/copyright/gi) {
    } else {
        s/^/Copyright (C) 20XX byYours Truly/;
        print("$_\n");
    }
}

output:
Copyright (C) 20XX byYours TrulyHello
Copyright (C) 20XX byYours Trulythis
Copyright (C) 20XX byYours Trulya
Copyright (C) 20XX byYours Trulytest
```

{{ page.date | date_to_string }}