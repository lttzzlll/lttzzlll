---
layout: default
title: 学习正则表达式
---
　　
{{ page.title }}
正则表达式功能：查找某个字符串，返回“匹配上”或者“匹配不上”。  
* 一般将正则表达式的模式放在正斜线(//)之间，如下：
```
Perl
$_ = "yabba dabba doo";
if (/abba/) { // 默认匹配$_的内容
    print "It matched!\n";
}
输出：It matched! #注意换行
```
表达式/abba/将在$_寻找这四个字母。如果找到，返回true，否则，false。   
如果找到了，则匹配上；否则，没有匹配上。   
注意：由于模式匹配成功通常返回true或false，因此经常用在if或while的条件表达式中。   
所有在双引号中的转义字符在模式中均有效。包括\t,\n等等。   
* 元字符   
在正则表达式中具有特殊含义的字符。   

| 元字符 | 名称| 功能 | 常用 |
| :-----: | :-----: | :-----: | :-----: |
| . | 通配符 | 匹配任何单个的字符（但不包括换行符\n） | .* 任意字符串匹配模式 -> 任意的字符串均能被匹配上（不包括换行符） |
| \ | 反斜线 | 将元字符变成普通的字符 \\ |  |
| * | 数量词 | 匹配前一项0次或者多次 |  |
| + | 数量词 | 匹配前一项1次或者多次 | |
| ? | 数量词 | 匹配前一项0次或者1次 | | 
| () | 分组 | | |
| | | 或者 | 匹配左边的或者右边的 | cat|dog |
| [] | 字符类 | 匹配括号内出现的任意单个字符 | [a-zA-Z0-9] |
| - | 连字号 | 表示某个范围 | [0-9A-Za-z] |
| ^ | 补集 | 表示某个集合的补集 | [^\d] 匹配数字之外的任意字符 |
| \d | 数字 | 数字的简写 | \d = [0-9] [^\d] 非数字的字符 |
| \w | 字符 | 表示字符 | \w = [a-zA-Z0-9_] 包括下划线（字母，数字，下划线）\w+匹配整个单词 [^\w] 非单词的字符 |
| \s | 空白 | 表示空白字符 | \s = [\f\t\n\r] \s*将匹配任何个数的空白字符（包括没有） \s+ 匹配一个以上的空白字符 [^\s] 非空白的字符 | 
| \D | [^\d]的补集 | 非数字的字符 | |
| \W | [^\w]的补集 | 非单词的字符 | | 
| \S | [^\s]的补集 | 非空白的字符 | |
| [\d\D] | 任何的数字，和任何非数字，指任何字符 | 匹配所有字符的一种通用方法 | /[\dA-Fa-f]+ 匹配16进制/ |
| [^\d\D] | 没有意义 | | |

元字符前使用反斜线将使它变成普通的字符。   

小练习   
1. 写一个程序，输出所有提到 fred的行（不要输出其它行）。如果输入字符串 Fred, fredrick, Alfred，能匹配上吗？准 备一个小的文本文件，其中包含如：“fred lintsotne”以及类似的信息。使用这个文本文件作为此程序的输入，以及本节 下面练习的输入。    
```
Perl
my @lines = qw/Fred, fredrick, Alfred/;
foreach $_(@lines) {
    if ($_ =~ /fred/) {
        print "mathed\n";
    } else {
        print "Do not matched!\n";
    }
}
output:   
Do not matched!   
mathed   
mathed    
```
2. 修改上面的程序，允许匹配 Fred。现在它能匹配，Fred, fredrick, Alfred 吗?（将这些名字加入输入文件中）    
```
Perl
my @lines = qw/Fred, fredrick, Alfred/;
foreach $_(@lines) {
    if ($_ =~ /fred/i) {
        print "mathed\n";
    } else {
        print "Do not matched!\n";
    }
}
output: 
mathed
mathed
mathed
```
3. 写一个程序，输出出现句号(.)的行，忽略其它行。使用前面练习中的文件进行练习：它能找到 Mr. Slate 吗？   
```
my @lines = qw/Fred, fredrick, Alfred, Mr.Slate/;
foreach $_(@lines) {
    if ($_ =~ /\./i) {
        print "$_\n";
    }
}
output:
Mr.Slate
```
4. 写一个程序，输出有一个字母大写，而非所有字母都大写的行。它能匹配Fred，而不匹配 fred和 FRED吗？   
```
my @lines = qw/Fred, fredrick, Alfred, Mr.Slate/;
foreach $_(@lines) {
    if ($_ =~ /[A-Z]+[a-z]+|[a-z]+[A-Z]+/) {
        print "$_\n";
    }
}
output:
Fred,
Alfred,
Mr.Slate
```
5. 额外的练习：写一个程序，它能输出所有同时提到 wilma和 fred 的行   
```
my $line1 = "wlima and fred";
my $line2 = "hello wlima";
my $line3 = "hello fred";
my $line4 = "fuck you!";
my @line = ();
push @line, $line1;
push @line, $line2;
push @line, $line3;
push @line, $line4;

foreach $_(@line) {
    if ($_ =~ /wlima/ && $_ =~ /fred/) {
        print "$_\n";
    }
}
```
{{ page.date | date_to_string }}