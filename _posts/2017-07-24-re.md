---
layout: default
title: 学习正则表达式
---
　　
{{ page.title }}
正则表达式功能：查找某个字符串，返回“匹配上”或者“匹配不上”。  
* 一般将正则表达式的模式放在正斜线(//)之间，如下：
```
Perl
$_ = "yabba dabba doo";
if (/abba/) { // 默认匹配$_的内容
    print "It matched!\n";
}
输出：It matched! #注意换行
```
表达式/abba/将在$_寻找这四个字母。如果找到，返回true，否则，false。   
如果找到了，则匹配上；否则，没有匹配上。   
注意：由于模式匹配成功通常返回true或false，因此经常用在if或while的条件表达式中。   
所有在双引号中的转义字符在模式中均有效。包括\t,\n等等。   
* 元字符   
在正则表达式中具有特殊含义的字符。   

| 元字符 | 名称| 功能 | 常用 |
| :-----: | :-----: | :-----: | :-----: |
| . | 通配符 | 匹配任何单个的字符（但不包括换行符\n） | .* 任意字符串匹配模式 -> 任意的字符串均能被匹配上（不包括换行符） |
| \ | 反斜线 | 将元字符变成普通的字符 \\ |  |
| * | 数量词 | 匹配前一项0次或者多次 |  |
| + | 数量词 | 匹配前一项1次或者多次 | |
| ? | 数量词 | 匹配前一项0次或者1次 | | 
| () | 分组 | | |
| | | 或者 | 匹配左边的或者右边的 | cat|dog |
| [] | 字符类 | 匹配括号内出现的任意单个字符 | [a-zA-Z0-9] |
| - | 连字号 | 表示某个范围 | [0-9A-Za-z] |
| ^ | 补集 | 表示某个集合的补集 | [^\d] 匹配数字之外的任意字符 |
| \d | 数字 | 数字的简写 | \d = [0-9] [^\d] 非数字的字符 |
| \w | 字符 | 表示字符 | \w = [a-zA-Z0-9_] 包括下划线（字母，数字，下划线）\w+匹配整个单词 [^\w] 非单词的字符 |
| \s | 空白 | 表示空白字符 | \s = [\f\t\n\r] \s*将匹配任何个数的空白字符（包括没有） \s+ 匹配一个以上的空白字符 [^\s] 非空白的字符 | 
| \D | [^\d]的补集 | 非数字的字符 | |
| \W | [^\w]的补集 | 非单词的字符 | | 
| \S | [^\s]的补集 | 非空白的字符 | |
| [\d\D] | 任何的数字，和任何非数字，指任何字符 | 匹配所有字符的一种通用方法 | /[\dA-Fa-f]+ 匹配16进制/ |
| [^\d\D] | 没有意义 | | |
| {} | 数量词 | 表示数量的范围 | {0, 3}, {0, }, {, 3} 包含上下界 * == {0, }, + == {1, }, ? == {0, 1} |

元字符前使用反斜线将使它变成普通的字符。   

小练习   
1. 写一个程序，输出所有提到 fred的行（不要输出其它行）。如果输入字符串 Fred, fredrick, Alfred，能匹配上吗？准 备一个小的文本文件，其中包含如：“fred lintsotne”以及类似的信息。使用这个文本文件作为此程序的输入，以及本节 下面练习的输入。    
```
Perl
my @lines = qw/Fred, fredrick, Alfred/;
foreach $_(@lines) {
    if ($_ =~ /fred/) {
        print "mathed\n";
    } else {
        print "Do not matched!\n";
    }
}
output:   
Do not matched!   
mathed   
mathed    
```
2. 修改上面的程序，允许匹配 Fred。现在它能匹配，Fred, fredrick, Alfred 吗?（将这些名字加入输入文件中）    
```
Perl
my @lines = qw/Fred, fredrick, Alfred/;
foreach $_(@lines) {
    if ($_ =~ /fred/i) {
        print "mathed\n";
    } else {
        print "Do not matched!\n";
    }
}
output: 
mathed
mathed
mathed
```
3. 写一个程序，输出出现句号(.)的行，忽略其它行。使用前面练习中的文件进行练习：它能找到 Mr. Slate 吗？   
```
my @lines = qw/Fred, fredrick, Alfred, Mr.Slate/;
foreach $_(@lines) {
    if ($_ =~ /\./i) {
        print "$_\n";
    }
}
output:
Mr.Slate
```
4. 写一个程序，输出有一个字母大写，而非所有字母都大写的行。它能匹配Fred，而不匹配 fred和 FRED吗？   
```
my @lines = qw/Fred, fredrick, Alfred, Mr.Slate/;
foreach $_(@lines) {
    if ($_ =~ /[A-Z]+[a-z]+|[a-z]+[A-Z]+/) {
        print "$_\n";
    }
}
output:
Fred,
Alfred,
Mr.Slate
```
5. 额外的练习：写一个程序，它能输出所有同时提到 wilma和 fred 的行   
```
my $line1 = "wlima and fred";
my $line2 = "hello wlima";
my $line3 = "hello fred";
my $line4 = "fuck you!";
my @line = ();
push @line, $line1;
push @line, $line2;
push @line, $line3;
push @line, $line4;

foreach $_(@line) {
    if ($_ =~ /wlima/ && $_ =~ /fred/) {
        print "$_\n";
    }
}
```

> m// == //  
> m(fred) == m<fred> == m{fred} == m[fred] == m,fred, == m!fred! == m^fred^
> /http:\/\// == m%http://% == m{http://}  
> 正斜线不是元字符，如果它不是分隔符，则不需要在前面使用反斜线。  
可选的修饰符   
| 修饰符 | 功能 | 常用 | 
| :-----: | :-----: | :-----: |
| /i | 不区分大小写 | /pattern/i |
| /s | 匹配任何字符 | /.*/s . 不匹配换行符，但是当 /.*/s 添加时，可以匹配换行符 |
| /x | 允许在模式中添加空格 | /-? \d+ \.? \d* /x (匹配数字) |

锚定：模式可以在特定的位置进行匹配   
| 符号 | 功能 | 常用 |
| :-----: | :-----: | :-----: |
| ^ | 在字符串的开头进行匹配 | /^hello/ | 
| & | 在字符串的结尾进行匹配 | /hello$/ (可能会匹配结尾的换行符) |
/^\s*$/ 匹配一个空行  
> 词界锚定：\b，针对单次使用 /\bhello\b/ 匹配 "hello"，不能匹配 "helloworld"，相当于全词匹配。   
> 给定字符串总有偶数个词界，每一个词均有两个界限（开始和结尾）。    
> 词是字母，数字，下划线组成的序列。 /\w+/ == /[A-Za-Z0-9_]+/   
> 单词上的引号不会改变词界的位置。   每一个单词上的引号都会使得单词的词界从此处重新开始。   
> 非词界锚定：\B，他将在任何非\b匹配的点上进行匹配。 /\bsearch\B/ 将匹配searches, searching, searched，但是不能匹配search，或者researching。   
> 绑定操作符 =~，将右边的模式在左边的字符串上进行匹配，默认对$_上的内容进行匹配。  
正则表达式可以被内插，作为内嵌的变量插入待匹配的模式中。   
匹配变量，允许取出相应的字符串。  
```
$_ = "Hello there, neighbor";
if (/\s(\w+),/) {
    print("the word was $1\n");
}
output:
the word was there
$_ = "Hello there, neighbor";
if (/(S+) (S+) (S+)/) {
    print("words were $1 $2 $3");
}
output:
words were Hello there neighbor
```
> 匹配变量可能是空的，如果没有被匹配上，匹配变量的值可能为空串。   
> 不同于undefined，如果模式中只有3个或者更少的括号，那么 $4为undef
```
my $dino = "I fear that I'll be extinct after 1000 years";
if ($dino =~ /(\d*) years/) {
    print("That's said '$1' years.\n");
}
output:
That's said '1000' years.

my dino = "I fear that I'll be extinct after a few millions years.";
if ($dino =~ /(\d*) years/) {
    print("That's said '$1' years.\n");
}
output:
That's said '' years.
```
匹配变量的值会保持不变，直到下一个模式成功匹配。一个没有匹配成功的模式将不会改变内存中相应的值，但一个匹配上的模式将重写此内存。  所以每次匹配的时候都要用if判断一下有没有匹配成功。

优先级
1. ()
2. 数量词
3. 锚定和序列
4. | 

小练习   
1. 使用模式测试程序。创造一个模式能匹配字符串match。使用字符串beforematchafter 进行测试。输出结果将其三部分放在正确位置了吗？
```
my $line = "beforematchafter";
my $match = "(before)(match)(after)";
if ($line =~ /$match/) {
    print("$1, $2, $3");
}
output:
before, match, after
```
2. 使用模式测试程序，创造一个模式能匹配任何单词（\w 意义下的单词），但这个单词必需以字母a 结尾。它匹配 wilma 而没匹配 barney 吗？它匹配 Mrs. Wilma Flintstone 吗? wilma&fred 呢？使用前一章习题的文件进行练习（如果没有上 述字符串，则加上它们）
```
my @line = ();
push @line, "wilma";
push @line, "barney";
push @line, "Mrs. Wilma Flintstone";
push @line, "wilma&fred";
foreach $_(@line) {
    if ($_ =~ /a\b/) {
        print("$_\n");
    }
}
output:
wilma
Mrs. Wilma Flintstone
wilma&fred
```
3. 修改第二题的程序，使之将由a结尾的单词放到$1之中。同时修改源代码，使此变量对应的值被放在单引号之中， 如$1 containsW‘ ilma’ 。
```
my @line = ();
push @line, "wilma";
push @line, "barney";
push @line, "Mrs. Wilma Flintstone";
push @line, "wilma&fred";
foreach $_(@line) {
    if ($_ =~ /(a\b)/) {
        print("'$1'\n");
    }
}
output:
'a'
'a'
'a'
```
4. 额外练习：修改第三题程序，使之能捕捉由 a 结尾的单词之后的 5 个字符（如果有那么多），并将之放入一个独立变量中。例如，如果输入的是 I saw Wilma yesterday, 则紧接的 5个字符是 yest（前有空格）。如果输入是 I, Wilma!， 则只有一个字符。它现在还能匹配 wilma吗？
```
my @line = ();
push @line, "wilma";
push @line, "barney";
push @line, "Mrs. Wilma Flintstone";
push @line, "wilma&fred";
foreach $_(@line) {
    if ($_ =~ /(a\b)(.{0,5})/) {
        print("'$2'\n");
    }
}
output:
''
' Flin'
'&fred'
```
5. 写一个程序（不是测试程序），能输出任何由空白结尾的输入行（非换行符）。在输出的结尾处放置一个标记符，使之能标记出空白。
```
my @line = ();
push @line, "wilma ";
push @line, "barney  ";
push @line, "Mrs. Wilma Flintstone  ";
push @line, "wilma&fred         ";
foreach $_(@line) {
    if ($_ =~ s/(\s+)$/-/) {
        print("'$_'\n");
    }
}
output:
'wilma-'
'barney-'
'Mrs. Wilma Flintstone-'
'wilma&fred-'
```
{{ page.date | date_to_string }}